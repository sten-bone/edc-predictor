#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/time.h>
#include <omp.h>

#define MAX_ARGS 10
#define REC_LENGTH 49   // size of a record in db
#define REC_WINDOW 10   // number of records to read at a time
#define LATITUDE_POS 28 // location of latitude coordinates in input record
#define OPEN 10000      // initial value of nearest neighbors
struct neighbor {
    char entry[REC_LENGTH];
    double dist;
};

/**
* This program finds the k-nearest neighbors
* Usage:	./nn <filelist> <num> <target latitude> <target longitude>
*			filelist: File with the filenames to the records
*			num: Number of nearest neighbors to find
*			target lat: Latitude coordinate for distance
*calculations
*			target long: Longitude coordinate for distance
*calculations
* The filelist and data are generated by hurricane_gen.c
* REC_WINDOW has been arbitrarily assigned; A larger value would allow more work
*for the threads
*/
int main(int argc, char *argv[]) {
    FILE *flist, *fp;
    int i = 0, j = 0, k = 0, rec_count = 0, done = 0; // 0 0 2 1
    char sandbox[REC_LENGTH * REC_WINDOW], *rec_iter, dbname[64]; // 0 0 2 1/2
    struct neighbor *neighbors = NULL; // 0 0 2 1
    float target_lat, target_long, tmp_lat = 0, tmp_long = 0; // 0 0 2 1

    if (argc < 5) { // 0 0 2 1
        fprintf(stderr, "Invalid set of arguments\n");
        exit(-1);
    }

    flist = fopen(argv[1], "r"); // 0 0 2 1/2
    if (!flist) { // 0 0 2 1
        printf("error opening flist\n");
        exit(1);
    }

    k = atoi(argv[2]); // 0 0 2 1/2
    target_lat = atof(argv[3]); // 0 0 2 1/2
    target_long = atof(argv[4]); // 0 0 2 1/2

    neighbors = malloc(k * sizeof(struct neighbor)); // 0 0 2 1

    if (neighbors == NULL) { // 0 0 2 1
        fprintf(stderr, "no room for neighbors\n");
        exit(0);
    }

    for (j = 0; j < k; // 1 0 2 0
         j++) { // Initialize list of nearest neighbors to very large dist
        neighbors[j].dist = OPEN; // 2 0 0 1
    }

    /**** main processing ****/
    if (fscanf(flist, "%s\n", dbname) != 1) { // 0 0 2 1
        fprintf(stderr, "error reading filelist\n");
        exit(0);
    }

    fp = fopen(dbname, "r"); // 0 0 2 1
    if (!fp) { // 0 0 2 1
        printf("error opening flist\n");
        exit(1);
    }

    float *z;
    z = (float *)malloc(REC_WINDOW * sizeof(float)); // 0 0 2 1

    while (!done) { // 1 0 2 1
        // Read in REC_WINDOW number of records
        rec_count = fread(sandbox, REC_LENGTH, REC_WINDOW, fp); // 2 0 0 1
        if (rec_count != REC_WINDOW) { // 2 0 0 1
            if (!ferror(flist)) { // 2 0 0 1
                fclose(fp); // 2 0 0 1

                if (feof(flist)) // 2 0 0 1
                    done = 1; // 2 0 0 1
                else { // 2 0 0 1
                    if (fscanf(flist, "%s\n", dbname) != 1) { // 2 0 0 1
                        fprintf(stderr, "error reading filelist\n"); // 2 0 0 1
                        exit(0); // 2 0 0 1
                    }

                    fp = fopen(dbname, "r"); // 2 0 0 1

                    if (!fp) { // 2 0 0 1
                        printf("error opening a db\n"); // 2 0 0 1
                        exit(1); // 2 0 0 1
                    }
                }
            } else { // 2 0 0 1
                perror("Error"); // 2 0 0 1
                exit(0); // 2 0 0 1
            }
        }

/* Launch threads to  */
#pragma omp parallel for shared(z, target_lat, target_long) private(           \
    i, rec_iter, tmp_lat, tmp_long)
        for (i = 0; i < rec_count; i++) { // 1 0 2 0
            rec_iter = sandbox + (i * REC_LENGTH + LATITUDE_POS - 1); // 2 0 0 1
            sscanf(rec_iter, "%f %f", &tmp_lat, &tmp_long); // 2 0 0 1
            z[i] = sqrt(((tmp_lat - target_lat) * (tmp_lat - target_lat)) + 
                        ((tmp_long - target_long) * (tmp_long - target_long))); // 2 0 0 1
        } /* omp end parallel */
#pragma omp barrier

        for (i = 0; i < rec_count; i++) { // 1 1 0 0
            float max_dist = -1; // 2 0 0 1
            int max_idx = 0; // 2 0 0 1
            // find a neighbor with greatest dist and take his spot if allowed!
            for (j = 0; j < k; j++) { // 3 0 0 0
                if (neighbors[j].dist > max_dist) { // 3 0 0 1/2
                    max_dist = neighbors[j].dist; // 3 0 0 1/2
                    max_idx = j; // 3 0 0 1
                }
            }
            // compare each record with max value to find the nearest neighbor
            if (z[i] < neighbors[max_idx].dist) { // 2 0 0 1/2
                sandbox[(i + 1) * REC_LENGTH - 1] = '\0'; // 2 0 0 0
                strcpy(neighbors[max_idx].entry, sandbox + i * REC_LENGTH); // 2 0 0 1/2
                neighbors[max_idx].dist = z[i]; // 2 0 0 1/2
            }
        }
    } // End while loop

    // Yafan Update
    // if (getenv("OUTPUT")) {
    FILE* out = fopen("output.txt", "w"); // 0 0 1 0
    fprintf(out, "The %d nearest neighbors are:\n", k); // 0 0 1 1
    for (j = k - 1; j >= 0; j--) { // 1 0 0 0
        if (!(neighbors[j].dist == OPEN)) // 2 0 0 1/2
            fprintf(out, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist); // 2 0 0 1/3
    }
    fclose(out);
    // }

    fclose(flist);
    return 0;
}
